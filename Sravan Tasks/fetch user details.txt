import { LightningElement,track,wire } from 'lwc';
import getusers from '@salesforce/apex/userController.getusers';
const cols = [
    { label: 'Username', fieldName: 'UserUsername' ,
    type: 'url',
    typeAttributes: {label: { fieldName: 'Username' }, 
    },
    },

];
export default class Userdetails extends LightningElement
 {
   columns=cols;
   @track userList;
  // Method 2
   @wire(getusers) 
   wiredAccounts({data,error}){
        if (data) {
            let allRecord=[];
            data.forEach(element => {
                
                let val=Object.assign({},element);
                console.log(JSON.stringify(val))
                val.UserUsername='/'+val.Id;
                //val.Id='/'+val.Id;
                allRecord.push(val);
            });
             this.userList = allRecord;
        console.log(data); 
        } else if (error) {
        console.log(error);
        }
   }

// @wire (getusers) 
//   wiredAccounts({data,error}){
//     if (data) {
//     console.log(data); 
//     } else if (error) {
//     console.log(error);
//     }
// }
}


<template>
    <!-- <template for:each={wiredAccounts.data} for:item="usr">
         <p key={usr.id}>
              {usr.Username}
         </p>
    </template> -->
    <div style="height: 500px;">
        <template if:true={userList}>
             <lightning-datatable
                     key-field="id"
                     data={userList}
                     columns={columns}>
             </lightning-datatable>
        </template>
        </div>
</template>


public class userController {
 //@AuraEnabled is annotation enables LWC to access below apex method
 //(cacheable=true) is for caching the data on client side storage without 
  // waiting for server trips. Which improves the performance
 @AuraEnabled(cacheable=true)
  public static List<User> getusers() {
  return [SELECT id,Username FROM User];
  }

}



“1. 𝗕𝗿𝗼𝗮𝗱𝗲𝗻 𝗬𝗼𝘂𝗿 𝗦𝗸𝗶𝗹𝗹 𝗦𝗲𝘁:
As a result of changing jobs regularly, you can gain new skills, gain new experience, 
and become a more well-rounded professional.

2. 𝗡𝗲𝗴𝗼𝘁𝗶𝗮𝘁𝗶𝗻𝗴 𝗢𝗽𝗽𝗼𝗿𝘁𝘂𝗻𝗶𝘁𝘆:
Negotiating your salary or other compensation can be easier if you frequently change jobs and companies.
You will have a better chance of understanding the market value of your skills when you take on new roles.

3. 𝗘𝘅𝗽𝗼𝘀𝘂𝗿𝗲 𝘁𝗼 𝗻𝗲𝘄 𝗶𝗻𝗱𝘂𝘀𝘁𝗿𝗶𝗲𝘀 𝗮𝗻𝗱 𝗿𝗼𝗹𝗲𝘀:
If you change jobs every few years, you can explore different industries and roles that may be more suitable for you.
A job change can help you gain insight into new roles, acquire new skills and certifications, and enhance your resume.

4. 𝗜𝗺𝗽𝗿𝗼𝘃𝗲𝗱 𝗹𝗼𝗻𝗴-𝘁𝗲𝗿𝗺 𝗷𝗼𝗯 𝘀𝗮𝘁𝗶𝘀𝗳𝗮𝗰𝘁𝗶𝗼𝗻:
By changing roles, you’ll have the ability to continually challenge yourself, continue to make an impact, 
and have better long-term job satisfaction.

5. 𝗘𝘅𝗽𝗮𝗻𝗱 𝗬𝗼𝘂𝗿 𝗡𝗲𝘁𝘄𝗼𝗿𝗸:
Every job is a chance to expand your network – with potential mentors, collaborators, and employers.
Having that wide reach can be incredibly useful on the job market, potentially giving you an advantage 
over other jobseekers.

Changing jobs frequently can be scary, but if you can manage it strategically, you’ll stay up to date, 
gain new skills and build a wide network that can open many more doors and opportunities for your future.”
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
https://lnkd.in/dqZ3ff7g

public without sharing class BeerListController {
@AuraEnabled(cacheable=true)
public static list<Beer__c> getBeerList(Integer limitSize, Integer offset){
    try {
        return [Select id,Alcohol__c, brewery_id__c,Image__c , Price__c, Id__c,Name from Beer__c LIMIT :limitSize
        OFFSET :offset];
    } catch (Exception e) {
        throw new AuraHandledException(e.getMessage());
    }
}
@AuraEnabled(cacheable=true)
public static list<Beer__c> getBeerListFiltrerd(String name){
    try {
        return [Select id,Alcohol__c, brewery_id__c,Image__c , Price__c, Id__c,Name from Beer__c where Name like :'%'+name+'%' Limit 10];
    } catch (Exception e) {
        throw new AuraHandledException(e.getMessage());
    }
}
}
============================
<template>

   <template if:true={beerList}>
    <div class="beersDiv"  style="overflow:scroll; height:400px;" onscroll={handleScroll1}>
    <lightning-layout multiple-rows>
    <template for:each={beerList} for:item="item">
        <lightning-layout-item size="4" key={item.Id}>
        <c-beer-tile2 beer-record={item}></c-beer-tile2>
        </lightning-layout-item>
    </template>
    </lightning-layout>
</div>
   </template>

   <template if:true={isLoading}>
    <div>
        <lightning-spinner alternative-text="Loading" size="small"></lightning-spinner>
    </div>
   </template>
</template>


JS
import { LightningElement, track } from 'lwc';
import getBeerList from '@salesforce/apex/BeerListController.getBeerList';
export default class BeerList2 extends LightningElement {
    
    lastScrollTop=0
    rowLimit =10;
    rowOffSet=0;
    error;
    @track beerList = [];

    isLoading = false;
    connectedCallback() {
        this.loadData();
    }

    loadData(){
        return  getBeerList({ limitSize: this.rowLimit , offset : this.rowOffSet })
        .then(result => {
            let updatedList = [...this.beerList, ...result];
            this.beerList = updatedList;
            this.error = undefined;
        })
        .catch(error => {
            this.error = error;
            this.beerList = undefined;
        });
    }
    
    handleScroll1(){
        let element=this.template.querySelector('.beersDiv');
        console.log('Handling1 Scroll'+element.scrollTop+' --- '+element.scrollHeight);
        if (element.scrollTop < this.lastScrollTop){
            // it's an Up Scroll 
            return;
         } 

         this.lastScrollTop = element.scrollTop <= 0 ? 0 : element.scrollTop;

          if (element.scrollTop + element.offsetHeight>= element.scrollHeight ){
            // Reached the End of The Div Query Next Set of Data
            this.isLoading = true;
            this.rowOffSet = this.rowOffSet + this.rowLimit;
            console.log("End");
            this.loadData()
            .then(()=> {
                console.log('Updated data');
                this.isLoading = false;
            });   
          }
    }  
}
=============================================
<template>
       
    <lightning-card title={beerRecord.Name}>
        <p class="slds-p-horizontal_small">
            <img src={beerRecord.Image__c} width="100" height="35" >
        </p>
        <lightning-layout multiple-rows>
            <lightning-layout-item size="12">
                <div class="custom-box"><b>Beer ID:</b> {beerRecord.Id__c}</div>
            </lightning-layout-item>
            <lightning-layout-item size="12"  >
                <div class="custom-box"><b>Alchohal %:</b> {beerRecord.Alcohol__c}</div>
            </lightning-layout-item>
            <lightning-layout-item size="12"  >
                <div class="custom-box"><b>Price:</b> {beerRecord.Price__c}</div>
            </lightning-layout-item>
            <lightning-layout-item size="12"  >
                <div class="custom-box"><b>Brewery id:</b> {beerRecord.brewery_id__c}</div>
            </lightning-layout-item>
        </lightning-layout>

        <div slot="footer">
            <lightning-button variant="success" label="Add to Cart" title="Add to Cart" onclick={FunctionName}></lightning-button>
            
        </div>
    </lightning-card>
</template>

JS
import { api, LightningElement } from 'lwc';

export default class BeerTile2 extends LightningElement {

    @api
    beerRecord
}
============================================================================================
public class pro_task implements Database.Batchable<sObject>
{
    public Database.QueryLocator start(Database.BatchableContext bc)
    {
        String oppList='select id,closeDate,stageName from Opportunity';
        return database.getQueryLocator(oppList);
    }
    public void execute(database.BatchableContext bc, List<Opportunity> opps)
    {
        List<Opportunity> updateOpps=new List<Opportunity>();
        for(Opportunity o: opps)
        {
            if(o.closeDate==System.today())
            {
                o.stageName='Closed Lost';
                updateOpps.add(o);
            }
        }
        update updateOpps;
    }
    public void finish(database.BatchableContext bc)
    {
        AsyncApexJob a = [Select Id, Status,NumberOfErrors,JobItemsProcessed,TotalJobItems, CreatedBy.Email
        				  from AsyncApexJob where Id =:bc.getJobId()];
        
         Messaging.SingleEmailMessage msg=new Messaging.SingleEmailMessage();
         String[] toAddresses = new String[] {a.CreatedBy.Email};
         msg.setToAddresses(toAddresses);
		 msg.setSubject('Match Merge Batch ' + a.Status);
         msg.setPlainTextBody('records processed ' + a.TotalJobItems +'with '+ a.NumberOfErrors + ' failures.');
         Messaging.sendEmail(new Messaging.singleEmailMessage[]{msg});
    }
}