import { LightningElement,track,wire } from 'lwc';
import getusers from '@salesforce/apex/userController.getusers';
const cols = [
    { label: 'Username', fieldName: 'UserUsername' ,
    type: 'url',
    typeAttributes: {label: { fieldName: 'Username' }, 
    },
    },

];
export default class Userdetails extends LightningElement
 {
   columns=cols;
   @track userList;
  // Method 2
   @wire(getusers) 
   wiredAccounts({data,error}){
        if (data) {
            let allRecord=[];
            data.forEach(element => {
                
                let val=Object.assign({},element);
                console.log(JSON.stringify(val))
                val.UserUsername='/'+val.Id;
                //val.Id='/'+val.Id;
                allRecord.push(val);
            });
             this.userList = allRecord;
        console.log(data); 
        } else if (error) {
        console.log(error);
        }
   }

// @wire (getusers) 
//   wiredAccounts({data,error}){
//     if (data) {
//     console.log(data); 
//     } else if (error) {
//     console.log(error);
//     }
// }
}


<template>
    <!-- <template for:each={wiredAccounts.data} for:item="usr">
         <p key={usr.id}>
              {usr.Username}
         </p>
    </template> -->
    <div style="height: 500px;">
        <template if:true={userList}>
             <lightning-datatable
                     key-field="id"
                     data={userList}
                     columns={columns}>
             </lightning-datatable>
        </template>
        </div>
</template>


public class userController {
 //@AuraEnabled is annotation enables LWC to access below apex method
 //(cacheable=true) is for caching the data on client side storage without 
  // waiting for server trips. Which improves the performance
 @AuraEnabled(cacheable=true)
  public static List<User> getusers() {
  return [SELECT id,Username FROM User];
  }

}



â€œ1. ğ—•ğ—¿ğ—¼ğ—®ğ—±ğ—²ğ—» ğ—¬ğ—¼ğ˜‚ğ—¿ ğ—¦ğ—¸ğ—¶ğ—¹ğ—¹ ğ—¦ğ—²ğ˜:
As a result of changing jobs regularly, you can gain new skills, gain new experience, 
and become a more well-rounded professional.

2. ğ—¡ğ—²ğ—´ğ—¼ğ˜ğ—¶ğ—®ğ˜ğ—¶ğ—»ğ—´ ğ—¢ğ—½ğ—½ğ—¼ğ—¿ğ˜ğ˜‚ğ—»ğ—¶ğ˜ğ˜†:
Negotiating your salary or other compensation can be easier if you frequently change jobs and companies.
You will have a better chance of understanding the market value of your skills when you take on new roles.

3. ğ—˜ğ˜…ğ—½ğ—¼ğ˜€ğ˜‚ğ—¿ğ—² ğ˜ğ—¼ ğ—»ğ—²ğ˜„ ğ—¶ğ—»ğ—±ğ˜‚ğ˜€ğ˜ğ—¿ğ—¶ğ—²ğ˜€ ğ—®ğ—»ğ—± ğ—¿ğ—¼ğ—¹ğ—²ğ˜€:
If you change jobs every few years, you can explore different industries and roles that may be more suitable for you.
A job change can help you gain insight into new roles, acquire new skills and certifications, and enhance your resume.

4. ğ—œğ—ºğ—½ğ—¿ğ—¼ğ˜ƒğ—²ğ—± ğ—¹ğ—¼ğ—»ğ—´-ğ˜ğ—²ğ—¿ğ—º ğ—·ğ—¼ğ—¯ ğ˜€ğ—®ğ˜ğ—¶ğ˜€ğ—³ğ—®ğ—°ğ˜ğ—¶ğ—¼ğ—»:
By changing roles, youâ€™ll have the ability to continually challenge yourself, continue to make an impact, 
and have better long-term job satisfaction.

5. ğ—˜ğ˜…ğ—½ğ—®ğ—»ğ—± ğ—¬ğ—¼ğ˜‚ğ—¿ ğ—¡ğ—²ğ˜ğ˜„ğ—¼ğ—¿ğ—¸:
Every job is a chance to expand your network â€“ with potential mentors, collaborators, and employers.
Having that wide reach can be incredibly useful on the job market, potentially giving you an advantage 
over other jobseekers.

Changing jobs frequently can be scary, but if you can manage it strategically, youâ€™ll stay up to date, 
gain new skills and build a wide network that can open many more doors and opportunities for your future.â€
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
https://lnkd.in/dqZ3ff7g

public without sharing class BeerListController {
@AuraEnabled(cacheable=true)
public static list<Beer__c> getBeerList(Integer limitSize, Integer offset){
    try {
        return [Select id,Alcohol__c, brewery_id__c,Image__c , Price__c, Id__c,Name from Beer__c LIMIT :limitSize
        OFFSET :offset];
    } catch (Exception e) {
        throw new AuraHandledException(e.getMessage());
    }
}
@AuraEnabled(cacheable=true)
public static list<Beer__c> getBeerListFiltrerd(String name){
    try {
        return [Select id,Alcohol__c, brewery_id__c,Image__c , Price__c, Id__c,Name from Beer__c where Name like :'%'+name+'%' Limit 10];
    } catch (Exception e) {
        throw new AuraHandledException(e.getMessage());
    }
}
}
============================
<template>

   <template if:true={beerList}>
    <div class="beersDiv"  style="overflow:scroll; height:400px;" onscroll={handleScroll1}>
    <lightning-layout multiple-rows>
    <template for:each={beerList} for:item="item">
        <lightning-layout-item size="4" key={item.Id}>
        <c-beer-tile2 beer-record={item}></c-beer-tile2>
        </lightning-layout-item>
    </template>
    </lightning-layout>
</div>
   </template>

   <template if:true={isLoading}>
    <div>
        <lightning-spinner alternative-text="Loading" size="small"></lightning-spinner>
    </div>
   </template>
</template>


JS
import { LightningElement, track } from 'lwc';
import getBeerList from '@salesforce/apex/BeerListController.getBeerList';
export default class BeerList2 extends LightningElement {
    
    lastScrollTop=0
    rowLimit =10;
    rowOffSet=0;
    error;
    @track beerList = [];

    isLoading = false;
    connectedCallback() {
        this.loadData();
    }

    loadData(){
        return  getBeerList({ limitSize: this.rowLimit , offset : this.rowOffSet })
        .then(result => {
            let updatedList = [...this.beerList, ...result];
            this.beerList = updatedList;
            this.error = undefined;
        })
        .catch(error => {
            this.error = error;
            this.beerList = undefined;
        });
    }
    
    handleScroll1(){
        let element=this.template.querySelector('.beersDiv');
        console.log('Handling1 Scroll'+element.scrollTop+' --- '+element.scrollHeight);
        if (element.scrollTop < this.lastScrollTop){
            // it's an Up Scroll 
            return;
         } 

         this.lastScrollTop = element.scrollTop <= 0 ? 0 : element.scrollTop;

          if (element.scrollTop + element.offsetHeight>= element.scrollHeight ){
            // Reached the End of The Div Query Next Set of Data
            this.isLoading = true;
            this.rowOffSet = this.rowOffSet + this.rowLimit;
            console.log("End");
            this.loadData()
            .then(()=> {
                console.log('Updated data');
                this.isLoading = false;
            });   
          }
    }  
}
=============================================
<template>
       
    <lightning-card title={beerRecord.Name}>
        <p class="slds-p-horizontal_small">
            <img src={beerRecord.Image__c} width="100" height="35" >
        </p>
        <lightning-layout multiple-rows>
            <lightning-layout-item size="12">
                <div class="custom-box"><b>Beer ID:</b> {beerRecord.Id__c}</div>
            </lightning-layout-item>
            <lightning-layout-item size="12"  >
                <div class="custom-box"><b>Alchohal %:</b> {beerRecord.Alcohol__c}</div>
            </lightning-layout-item>
            <lightning-layout-item size="12"  >
                <div class="custom-box"><b>Price:</b> {beerRecord.Price__c}</div>
            </lightning-layout-item>
            <lightning-layout-item size="12"  >
                <div class="custom-box"><b>Brewery id:</b> {beerRecord.brewery_id__c}</div>
            </lightning-layout-item>
        </lightning-layout>

        <div slot="footer">
            <lightning-button variant="success" label="Add to Cart" title="Add to Cart" onclick={FunctionName}></lightning-button>
            
        </div>
    </lightning-card>
</template>

JS
import { api, LightningElement } from 'lwc';

export default class BeerTile2 extends LightningElement {

    @api
    beerRecord
}
============================================================================================
public class pro_task implements Database.Batchable<sObject>
{
Â  Â  public Database.QueryLocator start(Database.BatchableContext bc)
Â  Â  {
Â  Â  Â  Â  String oppList='select id,closeDate,stageName from Opportunity';
Â  Â  Â  Â  return database.getQueryLocator(oppList);
Â  Â  }
Â  Â  public void execute(database.BatchableContext bc, List<Opportunity> opps)
Â  Â  {
Â  Â  Â  Â  List<Opportunity> updateOpps=new List<Opportunity>();
Â  Â  Â  Â  for(Opportunity o: opps)
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  if(o.closeDate==System.today())
Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  o.stageName='Closed Lost';
Â  Â  Â  Â  Â  Â  Â  Â  updateOpps.add(o);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  update updateOpps;
Â  Â  }
Â  Â  public void finish(database.BatchableContext bc)
Â  Â  {
Â  Â  Â  Â  AsyncApexJob a = [Select Id, Status,NumberOfErrors,JobItemsProcessed,TotalJobItems, CreatedBy.Email
Â  Â  Â  Â  				 Â from AsyncApexJob where Id =:bc.getJobId()];
Â  Â  Â  Â  
Â  Â  Â  Â  Â Messaging.SingleEmailMessage msg=new Messaging.SingleEmailMessage();
Â  Â  Â  Â  Â String[] toAddresses = new String[] {a.CreatedBy.Email};
Â  Â  Â  Â  Â msg.setToAddresses(toAddresses);
		 msg.setSubject('Match Merge Batch ' + a.Status);
Â  Â  Â  Â  Â msg.setPlainTextBody('records processed ' + a.TotalJobItems +'with '+ a.NumberOfErrors + ' failures.');
Â  Â  Â  Â  Â Messaging.sendEmail(new Messaging.singleEmailMessage[]{msg});
Â  Â  }
}